"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyCollection = void 0;
const Dictionary_1 = require("../Collections/Dictionary");
const List_1 = require("../Collections/List");
const PropertyDictionary_1 = require("../Collections/PropertyDictionary");
/**
 * Represents a set of dependencies.
 */
class DependencyCollection {
    /**
     * Initializes a new instance of the {@link DependencyCollection `DependencyCollection`} class.
     *
     * @param collection
     * The base collection.
     */
    constructor(collection) {
        var _a;
        this.dependencies = this.LoadDependencyDictionary(collection === null || collection === void 0 ? void 0 : collection.dependencies);
        this.devDependencies = this.LoadDependencyDictionary(collection === null || collection === void 0 ? void 0 : collection.devDependencies);
        this.peerDependencies = this.LoadDependencyDictionary(collection === null || collection === void 0 ? void 0 : collection.peerDependencies);
        this.optionalDependencies = this.LoadDependencyDictionary(collection === null || collection === void 0 ? void 0 : collection.optionalDependencies);
        this.bundledDependencies = this.LoadDependencyList((_a = collection === null || collection === void 0 ? void 0 : collection.bundledDependencies) !== null && _a !== void 0 ? _a : []);
    }
    /**
     * @inheritdoc
     */
    get AllDependencies() {
        let result = new Dictionary_1.Dictionary();
        for (let dependencies of [this.Dependencies, this.DevelopmentDependencies, this.OptionalDependencies, this.PeerDependencies]) {
            for (let dependency of dependencies.Keys) {
                if (!result.Has(dependency)) {
                    result.Add(dependency, dependencies.Get(dependency));
                }
            }
        }
        return result;
    }
    /**
     * @inheritdoc
     */
    get Dependencies() {
        return this.dependencies;
    }
    /**
     * @inheritdoc
     */
    get DevelopmentDependencies() {
        return this.devDependencies;
    }
    /**
     * @inheritdoc
     */
    get PeerDependencies() {
        return this.peerDependencies;
    }
    /**
     * @inheritdoc
     */
    get OptionalDependencies() {
        return this.optionalDependencies;
    }
    /**
     * @inheritdoc
     */
    get BundledDependencies() {
        return this.bundledDependencies;
    }
    /**
     * @inheritdoc
     *
     * @param collection
     * The collection to register.
     *
     * @param overwrite
     * A value indicating whether existing dependencies should be overwritten.
     */
    Register(collection, overwrite) {
        let keys = [
            "Dependencies",
            "DevelopmentDependencies",
            "PeerDependencies",
            "OptionalDependencies"
        ];
        for (let key of keys) {
            if (overwrite !== null && overwrite !== undefined) {
                let collectionToMutate = overwrite ? this : collection;
                for (let dependency of collection[key].Entries) {
                    if (this[key].Has(dependency[0])) {
                        collectionToMutate[key].Remove(dependency[0]);
                    }
                }
            }
            this[key].AddRange(collection[key]);
        }
        for (let dependency of collection.BundledDependencies.Values) {
            if (!this.BundledDependencies.Values.includes(dependency)) {
                this.BundledDependencies.Add(dependency);
            }
        }
    }
    /**
     * Clears all dependencies from the collection.
     */
    Clear() {
        let sets = [
            this.Dependencies,
            this.DevelopmentDependencies,
            this.PeerDependencies,
            this.OptionalDependencies,
            this.BundledDependencies
        ];
        for (let set of sets) {
            set.Clear();
        }
    }
    /**
     * Loads a dictionary which contains dependencies and corresponding versions.
     *
     * @param source
     * The object which contains the dependencies to load.
     *
     * @returns
     * The dependency-dictionary.
     */
    LoadDependencyDictionary(source) {
        return new PropertyDictionary_1.PropertyDictionary(source);
    }
    /**
     * Loads a list of dependencies.
     *
     * @param source
     * A set of dependencies to load.
     *
     * @returns
     * The newly created dependency-list.
     */
    LoadDependencyList(source) {
        return new List_1.List(source);
    }
}
exports.DependencyCollection = DependencyCollection;
//# sourceMappingURL=DependencyCollection.js.map